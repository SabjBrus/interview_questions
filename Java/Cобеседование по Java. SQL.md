# Cобеседование по Java. Разбор вопросов и ответов.


<a href="https://mc.yandex.ru/pixel/8711235002931986822?rnd=%aw_random%">
    <img src="https://mc.yandex.ru/pixel/8711235002931986822?rnd=%aw_random%" />        
  </a>&nbsp;&nbsp;
<a href="https://mc.yandex.ru/watch/92801430">
    <img src="https://mc.yandex.ru/watch/92801430" />        
  </a>&nbsp;&nbsp;


Нажмите ★, если вам нравится проект. Ваш вклад сердечно ♡ приветствуется.

Если вам интересно мое резюме: https://github.com/DEBAGanov

Обычно порядок операций в SQL запросе следующий:

`SELECT`: выборка столбцов, которые будут отображаться в результирующей таблице.
`FROM`: указание источника данных (одной или нескольких таблиц) для выполнения запроса.
`WHERE`: определение условия, по которому будут отобраны строки из источника данных.
`GROUP BY`: группировка строк на основе значений одного или нескольких столбцов.
`HAVING`: определение условия, применяемого к группировке строк.
`ORDER BY`: упорядочивание строк в результате выполнения запроса по заданному столбцу или группе столбцов.
`LIMIT/OFFSET`: ограничение количества строк в результирующей таблице.


`Ключевые слова` -	`Описание`
+ `ADD`	Добавляет столбец в существующую таблицу
+ `ADD` CONSTRAINT	Добавляет ограничение после того, как таблица уже создана
+ `ALTER`	Добавляет, удаляет или изменяет столбцы в таблице, а также изменяет данные тип столбца в таблице
+ `ALTER COLUMN`	Изменяет тип данных столбца в таблице
+ `ALTER TABLE`	Добавляет, удаляет или изменяет столбцы в таблице
+ `ALL`	Возвращает true, если все значения подзапроса соответствуют состояние
+ `AND`	Включает только строки, где оба условия истинны
+ `ANY`	Возвращает true, если какое-либо из значений подзапроса соответствует состоянию
+ `AS`	Переименовывает столбец или таблицу с помощью псевдонима
+ `ASC`	Сортировка результирующего набора в порядке возрастания
+ `BACKUP DATABASE`	Создает резервную копию существующей базы данных
+ `BETWEEN`	Выбор значений в заданном диапазоне
+ `CASE`	Создает различные выходные данные в зависимости от условий
+ `CHECK`	Ограничение, ограничивающее значение, которое может быть помещено в колонка
+ `COLUMN`	Изменяет тип данных столбца или удаляет столбец в таблице
+ `CONSTRAINT`	Добавляет или удаляет ограничение
+ `CREATE`	Создает базу данных, индекс, представление, таблицу или процедуру
+ `CREATE DATABASE`	Создает новую базу данных SQL
+ `CREATE INDEX`	Создает индекс в таблице (позволяет дублировать значения)
+ `CREATE OR REPLACE VIEW`	Обновление представления
+ `CREATE TABLE`	Создает новую таблицу в базе данных
+ `CREATE PROCEDURE`	Создает хранимую процедуру
+ `CREATE UNIQUE INDEX`	Создает уникальный индекс в таблице (без повторяющихся значений)
+ `CREATE VIEW`	Создает представление на основе результирующего набора инструкции SELECT
+ `DATABASE`	Создает или удаляет базу данных SQL
+ `DEFAULT`	Ограничение, предоставляющее значение по умолчанию для столбца
+ `DELETE`	Удаляет строки из таблицы
+ `DESC`	Сортировка результирующего набора в порядке убывания
+ `DISTINCT`	Выбирает только отдельные (разные) значения
+ `DROP`	Удаляет столбец, ограничение, базу данных, индекс, таблицу или представление
+ `DROP COLUMN`	Удаляет столбец в таблице
+ `DROP CONSTRAINT`	Удаляет UNIQUE, PRIMARY KEY, FOREIGN KEY, или ограничение CHECK
+ `DROP DATABASE`	Удаляет существующую базу данных SQL
+ `DROP DEFAULT`	Удаляет ограничение по умолчанию
+ `DROP INDEX`	Удаление индекса в таблице
+ `DROP TABLE`	Удаляет существующую таблицу в базе данных
+ `DROP VIEW`	Удаление представления
+ `EXEC`	Выполняет хранимую процедуру
+ `EXISTS`	Тесты на наличие любой записи в подзапросе
+ `FOREIGN KEY`	Ограничение, которое является ключом, используемым для связывания двух таблиц вместе
+ `FROM`	Указывает, из какой таблицы следует выбрать или удалить данные
+ `FULL OUTER JOIN`	Возвращает все строки при наличии совпадения в левой или правой таблице
+ `GROUP BY`	Группирует результирующий набор (используется с агрегатными функциями: COUNT, MAX, MIN, SUM, AVG)
+ `HAVING`	Используется вместо WHERE с агрегатными функциями
+ `IN	Позволяет указать несколько значений в предложении WHERE
+ `INDEX`	Создает или удаляет индекс в таблице
+ `INNER JOIN`	Возвращает строки, имеющие совпадающие значения в обеих таблицах
+ `INSERT INTO`	Вставка новых строк в таблицу
+ `INSERT INTO SELECT`	Копирует данные из одной таблицы в другую
+ `IS NULL`	Тесты для пустых значений
+ `IS NOT NULL`	Тесты для непустых значений
+ `JOIN`	Для объединения таблиц
+ `LEFT JOIN`	Возвращает все строки из левой таблицы и соответствующие строки из правой таблицы
+ `LIKE`	Поиск указанного шаблона в столбце
+ `LIMIT`	Задает количество записей, возвращаемых в результирующем наборе
+ `NOT`	Включает только строки, в которых условие не является истинным
+ `NOT NULL`	Ограничение, которое заставляет столбец не принимать нулевые значения
+ `OR`	Включает строки, в которых выполняется любое из условий
+ `ORDER BY`	Сортировка результирующего набора в порядке возрастания или убывания
+ `OUTER JOIN`	Возвращает все строки при наличии совпадения в левой или правой таблице
+ `PRIMARY KEY`	Ограничение, которое однозначно идентифицирует каждую запись в таблице базы данных
+ `PROCEDURE`	Хранимая процедура
+ `RIGHT JOIN`	Возвращает все строки из правой таблицы и соответствующие строки из левой таблицы
+ `ROWNUM`	Задает количество записей, возвращаемых в результирующем наборе
+ `SELECT`	Выбор данных из базы данных
+ `SELECT DISTINCT`	Выбирает только отдельные (разные) значения
+ `SELECT INTO`	Копирует данные из одной таблицы в новую таблицу
+ `SELECT TOP`	Задает количество записей, возвращаемых в результирующем наборе
+ `SET`	Указывает, какие столбцы и значения должны быть обновлены в таблице
+ `TABLE`	Создает таблицу, добавляет, удаляет или изменяет столбцы в таблице, а также удаляет таблицу или данные внутри таблицы
+ `TOP`	Задает количество записей, возвращаемых в результирующем наборе
+ `TRUNCATE TABLE`	Удаляет данные внутри таблицы, но не саму таблицу
+ `UNION`	Объединяет результирующий набор из двух или более операторов SELECT (только отдельные значения)
+ `UNION ALL`	Объединяет результирующий набор из двух или более операторов SELECT (позволяет дублировать значения)
+ `UNIQUE`	Ограничение, обеспечивающее уникальность всех значений в столбце
+ `UPDATE`	Обновление существующих строк в таблице
+ `VALUES`	Задает значения инструкции INSERT INTO
+ `VIEW`	Создает, обновляет или удаляет представление
+ `WHERE`	Фильтрует результирующий набор для включения только тех записей, которые удовлетворяют заданному условию




1. Что такое SQL?
2. Какой реляционный базовый язык используется в SQL?
3. Для чего необходимо использование SQL?
4. Какие преимущества имеет SQL перед другими реляционными базами данных?
5. Какие типы данных поддерживает SQL?
6. Что такое транзакция?
7. Что такое оператор SELECT?
8. Что такое WHERE?
9. Что такое ORDER BY?
10. Что такое GROUP BY?
11. Что такое HAVING?
12. Что такое JOIN?
13. Какие виды JOIN бывают в SQL?
14. Что такое INNER JOIN?
15. Что такое LEFT JOIN?
16. Что такое RIGHT JOIN?
17. Что такое FULL OUTER JOIN?
18. Что такое SELF JOIN?
19. Что такое UNION и UNION ALL?
20. Что такое SUBQUERY?
21. Что такое коррелирующий запрос?
22. Что такое представления (view)?
23. Каковы основные принципы проектирования базы данных?
24. Что такое нормализация?
25. Какие виды нормализации бывают в SQL?
26. Что такое индекс и какие виды индексов существуют?
27. Какой вид индекса использовать для какого типа запросов?
28. Как сделать определенное поле уникальным?
29. Что такое триггеры?
30. Как создать триггер в SQL?
31. Что такое ограничения (constraints) и какие они бывают?
32. Как создать таблицу с ограничениями?
33. Как изменить ограничения на существующей таблице?
34. Что такое хранимая процедура и как ее создать?
35. Что такое функция и как ее создать?
36. Какие функции поддерживает SQL?
37. Как работать с датами в SQL?
38. Что такое оператор CASE?
39. Что такое оператор COALESCE?
40. Что такое оператор LIKE?
41. Какие операторы сравнения поддерживает SQL?
42. Что такое агрегатные функции и какие они бывают?
43. Как работать с NULL-значениями в SQL?
44. Что такое инструкция TRUNCATE?
45. В чем разница между инструкцией DELETE и TRUNCATE?
46. Что такое ключевое слово DISTINCT?
47. Что такое ключевое слово LIMIT?
48. Что такое ключевое слово OFFSET?
49. Что такое ключевое слово TOP?
50. Что такое GROUP_CONCAT?
51. Что такое аналитические функции?
52. Какие аналитические функции поддерживает SQL?
53. Как использовать операторы BETWEEN и IN в SQL?
54. Что такое инструкция INSERT?
55. Какие виды инструкции INSERT бывают в SQL?
56. Что такое инструкция UPDATE?
57. Как работать с несколькими таблицами в одном запросе?
58. Как сделать выборку из таблицы по определенному диапазону значений?
59. Как работать с динамическими запросами в SQL?
60. Как произвести создание и удаление таблиц в SQL?
61. Какие виды ограничений можно использовать в SQL?
62. Как работать с индексами в SQL
63. Какие индексы могут быть использованы в SQL?
64. Что такое кластеризованный и некластеризованный индекс?
65. Какие операторы логических связок (AND, OR, NOT) существуют в SQL?
66. Что такое подзапросы и как они работают в SQL?
67. Как использовать операторы LIKE и NOT LIKE в SQL?
68. Какие виды функций агрегации существуют в SQL?
69. Что такое LEFT OUTER JOIN и RIGHT OUTER JOIN?
70. Как использовать ключевое слово DISTINCT для удаления дубликатов в SQL?
71. Как использовать операторы IN и NOT IN в SQL?
72. Что такое оконные функции и как они работают в SQL?
73. Как создать таблицу с помощью команды CREATE TABLE в SQL?
74. Как изменить структуру таблицы с помощью команды ALTER TABLE в SQL?
75. Как удалить таблицу с помощью команды DROP TABLE в SQL?
76. Как использовать операторы IS NULL и IS NOT NULL в SQL?
77. Что такое агрегатная функция SUM() и как она используется в SQL?
78. Как использовать операторы GROUP BY и HAVING в SQL?
79. Как использовать операторы ORDER BY и LIMIT в SQL?
80. Как сделать выборку строк из таблицы с помощью оператора SELECT в SQL?
81. Как использовать операторы BETWEEN и NOT BETWEEN в SQL?
82. Как работать с датами и временем в SQL?
83. Как создать индекс на одном или нескольких столбцах в SQL?
84. Что такое функция COUNT() и как она используется в SQL?
85. Как использовать оператор LIKE для поиска определенных значений в SQL?
86. Какие виды данных можно хранить в SQL?
87. Как использовать операторы AND и OR в SQL?
88. Как использовать ключевое слово LEFT JOIN в SQL?
89. Как использовать ключевое слово RIGHT JOIN в SQL?
90. Что такое таблица соединения и как она используется в SQL?
91. Как использовать оператор DISTINCT в SQL?
92. Что такое функция MAX() и как она используется в SQL?
93. Как использовать оператор UNION в SQL?
94. Что такое функция MIN() и как она используется в SQL?
95. Как использовать операторы IN и EXISTS в SQL?
96. Как использовать операторы LIKE и IN в SQL?
97. Что такое операторы ALL и ANY в SQL?
98. Как использовать операторы EXISTS и NOT EXISTS в SQL?
99. Как использовать операторы CASE и WHEN в SQL?
100. Как использовать операторы SELECT и INSERT в SQL?
101. Что такое RDBMS?
102. Какие типы данных поддерживает SQL?
103. Что такое таблица в SQL?
104. Как создать таблицу в SQL?
105. Как изменить таблицу в SQL?
106. Что такое ключевое поле (primary key) и как его использовать?
107. Что такое внешний ключ (foreign key) и как его использовать?
108. Что такое индекс и как его использовать?
109. Что такое транзакция и зачем она нужна?
110. Что такое COMMIT и ROLLBACK?
111. Что такое представление (view) и как его использовать?
112. Что такое процедура (stored procedure)?
113. Как создать процедуру в SQL?
114. Как вызвать процедуру в SQL?
115. Что такое функция (stored function) и как ее использовать?
116. Как создать функцию в SQL?
117. Как вызвать функцию в SQL?
118. Какие типы JOIN используются в SQL?
119. Что такое INNER JOIN?
120. Что такое LEFT JOIN?
121. Что такое RIGHT JOIN?
122. Что такое FULL OUTER JOIN?
123. Как использовать подзапрос (subquery) в SQL?
124. Какие виды операторов SELECT используются в SQL?
125. Что такое оператор DISTINCT и как его использовать?
126. Что такое оператор WHERE и как его использовать?
127. Что такое оператор GROUP BY и как его использовать?
128. Что такое оператор HAVING и как его использовать?
129. Что такое оператор ORDER BY и как его использовать?
130. Какие функции агрегации используются в SQL?
131. Что такое AVG и как его использовать?
132. Что такое SUM и как его использовать?
133. Что такое COUNT и как его использовать?
134. Что такое MAX и как его использовать?
135. Что такое MIN и как его использовать?
136. Как использовать условные операторы (CASE, IF) в SQL?
137. Что такое триггер (trigger) и как его использовать?
138. Как создать триггер в SQL?
139. Как удалить триггер в SQL?
140. Что такое индексы и как их использовать?
141. Что такое кластерный индекс (clustered index)?
142. Что такое некластерный индекс (non-clustered index)?
143. Какие виды баз данных бывают?
144. Что такое NoSQL?
145. Какие базы данных относятся к NoSQL?
146. Что такое MongoDB?
147. Что такое Redis?
148. Что такое Cassandra?
149. Что такое Couchbase?
150. Что такое HBase?
151. Что такое Neo4j?
152. Что такое Riak?
153. Что такое DynamoDB?
154. Как использовать MongoDB в Java-приложении?
155. Как использовать Redis в Java-приложении?
156. Как использовать Cassandra в Java-приложении?
157. Как использовать Couchbase в Java-приложении?
158. Как использовать HBase в Java-приложении?
159. Как использовать Neo4j в Java-приложении?
160. Как использовать Riak в Java-приложении?
161. Как использовать DynamoDB в Java-приложении?
162. Что такое ORM и какие библиотеки ORM для Java вы знаете?
163. Что такое Hibernate?
164. Как использовать Hibernate в Java-приложении?
165. Что такое JPA?
166. Как использовать JPA в Java-приложении?
68. Что такое JDBC?
69. Как использовать JDBC в Java-приложении?
70. Что такое Spring Data?
71. Как использовать Spring Data в Java-приложении?
72. Что такое MyBatis?
73. Как использовать MyBatis в Java-приложении?
74. Что такое Apache Camel?
75. Как использовать Apache Camel в Java-приложении?
76. Что такое ETL процесс?
77. Как реализовать ETL процесс с помощью Java?
78. Как улучшить производительность SQL запросов?
79. Как оптимизировать SQL запросы?
80. Как ускорить выполнение SQL запросов?
81. Что такое индексация в базах данных?
82. Как создать индексы в базе данных?
83. Как удалить индексы из базы данных?
84. Какие типы индексов бывают?
85. Что такое B-Tree индекс?
86. Что такое Hash индекс?
87. Что такое Bitmap индекс?
88. Что такое функциональный индекс?
89. Как работает оптимизатор запросов в базах данных?
90. Как узнать план выполнения запроса в базе данных?
91. Что такое deadlock и как его избежать?
92. Что такое SQL injection и как его предотвратить?
93. Как сделать backup базы данных?
94. Что такое резервное копирование?
95. Как восстановить базу данных из backup?
96. Что такое log shipping?
97. Как использовать log shipping для репликации базы данных?
98. Что такое многопоточность в базах данных?
99. Какие проблемы могут возникнуть при использовании многопоточности в базах данных?
100. Как решить проблемы с многопоточностью в базах данных?
101. Что такое репликация базы данных?
102. Как настроить репликацию базы данных?
103. Что такое масштабирование базы данных?
104. Как настроить масштабирование базы данных?
105. Что такое шардинг?
106. Как настроить шардинг в базе данных?
107. Что такое горизонтальный шардинг?
108. Что такое вертикальный шардинг?
109. Какой подход лучше для шардинга?
110. Что такое партиционирование таблицы?
111. Как настроить партиционирование таблицы?
112. Что такое отказоустойчивость базы данных?
113. Как обеспечить отказоустойчивость базы данных?
114. Что такое резервный сервер базы данных?
115. Как использовать резервный сервер базы данных?
116. Что такое кластер базы данных?
117. Как настроить кластер базы данных?
118. Что такое мониторинг базы данных?
119. Как настроить мониторинг базы данных?
120. Какие инструменты мониторинга базы данных вы знаете?
121. Что такое профилирование SQL запросов?
122. Как настроить профилирование SQL запросов?
123. Какие инструменты профилирования SQL запросов вы знаете?
124. Что такое миграции базы данных?
125. Как настроить миграции базы данных?
126. Какие инструменты миграции базы данных вы знаете?
127. Что такое архитектура базы данных?
128. Какие паттерны проектирования используются при проектировании базы данных?
129. Какие принципы SOLID применяются при разработке базы данных?
130. Что такое ER-модель?
131. Как использовать ER-модель для проектирования базы данных?
132. Что такое UML и как его использовать при проектировании базы данных?
133. Что такое «SQL»?
134. Какие существуют операторы SQL?
135. Что означает NULL в SQL?
136. Что такое «временная таблица»? Для чего она используется?
137. Что такое «представление» (view) и для чего оно применяется?
138. Каков общий синтаксис оператора SELECT?
139. Что такое JOIN?
140. Какие существуют типы JOIN?
141. Что лучше использовать JOIN или подзапросы?
142. Для чего используется оператор HAVING?
143. В чем различие между операторами HAVING и WHERE?
144. Для чего используется оператор ORDER BY?
145. Для чего используется оператор GROUP BY?
146. Как GROUP BY обрабатывает значение NULL?
147. В чем разница между операторами GROUP BY и DISTINCT?
148. Перечислите основные агрегатные функции.
149. В чем разница между COUNT(*) и COUNT({column})?
150. Что делает оператор EXISTS?
151. Для чего используются операторы IN, BETWEEN, LIKE?
152. Для чего применяется ключевое слово UNION?
153. Какие ограничения на целостность данных существуют в SQL?
154. Какие отличия между ограничениями PRIMARY и UNIQUE?
155. Может ли значение в столбце, на который наложено ограничение FOREIGN KEY, равняться NULL?
156. Как создать индекс?
157. Что делает оператор MERGE?
158. В чем отличие между операторами DELETE и TRUNCATE?
159. Что такое «хранимая процедура»?
160. Что такое «триггер»?
161. Что такое «курсор»?
162. Опишите разницу типов данных DATETIME и TIMESTAMP.
163. Для каких числовых типов недопустимо использовать операции сложения/вычитания?
164. Какое назначение у операторов PIVOT и UNPIVOT в Transact-SQL?
165. Расскажите об основных функциях ранжирования в Transact-SQL.
166. Для чего используются операторы INTERSECT, EXCEPT в Transact-SQL?


# SQL
- [Cобеседование по Java. Разбор вопросов и ответов.](#cобеседование-по-java-разбор-вопросов-и-ответов)
- [SQL](#sql)
  - [Что такое _«SQL»_?](#что-такое-sql)
  - [Какие существуют операторы SQL?](#какие-существуют-операторы-sql)
  - [Что означает `NULL` в SQL?](#что-означает-null-в-sql)
  - [Что такое _«временная таблица»_? Для чего она используется?](#что-такое-временная-таблица-для-чего-она-используется)
  - [Что такое _«представление» (view)_ и для чего оно применяется?](#что-такое-представление-view-и-для-чего-оно-применяется)
  - [Каков общий синтаксис оператора `SELECT`?](#каков-общий-синтаксис-оператора-select)
  - [Что такое `JOIN`?](#что-такое-join)
  - [Какие существуют типы `JOIN`?](#какие-существуют-типы-join)
  - [Что лучше использовать `JOIN` или подзапросы?](#что-лучше-использовать-join-или-подзапросы)
  - [Для чего используется оператор `HAVING`?](#для-чего-используется-оператор-having)
  - [В чем различие между операторами `HAVING` и `WHERE`?](#в-чем-различие-между-операторами-having-и-where)
  - [Для чего используется оператор `ORDER BY`?](#для-чего-используется-оператор-order-by)
  - [Для чего используется оператор `GROUP BY`?](#для-чего-используется-оператор-group-by)
  - [Как `GROUP BY` обрабатывает значение `NULL`?](#как-group-by-обрабатывает-значение-null)
  - [В чем разница между операторами `GROUP BY` и `DISTINCT`?](#в-чем-разница-между-операторами-group-by-и-distinct)
  - [Перечислите основные агрегатные функции.](#перечислите-основные-агрегатные-функции)
  - [В чем разница между `COUNT(*)` и `COUNT({column})`?](#в-чем-разница-между-count-и-countcolumn)
  - [Что делает оператор `EXISTS`?](#что-делает-оператор-exists)
  - [Для чего используются операторы `IN`, `BETWEEN`, `LIKE`?](#для-чего-используются-операторы-in-between-like)
  - [Для чего применяется ключевое слово `UNION`?](#для-чего-применяется-ключевое-слово-union)
  - [Какие ограничения на целостность данных существуют в SQL?](#какие-ограничения-на-целостность-данных-существуют-в-sql)
  - [Какие отличия между ограничениями `PRIMARY` и `UNIQUE`?](#какие-отличия-между-ограничениями-primary-и-unique)
  - [Может ли значение в столбце, на который наложено ограничение `FOREIGN KEY`, равняться `NULL`?](#может-ли-значение-в-столбце-на-который-наложено-ограничение-foreign-key-равняться-null)
  - [Как создать индекс?](#как-создать-индекс)
  - [Что делает оператор `MERGE`?](#что-делает-оператор-merge)
  - [В чем отличие между операторами `DELETE` и `TRUNCATE`?](#в-чем-отличие-между-операторами-delete-и-truncate)
  - [Что делает оператор `EXPLAIN`?](#что-делает-оператор-explain)
  - [Что такое _«RETURNING»_?](#что-такое-returning)
  - [Что такое _«хранимая процедура»_?](#что-такое-хранимая-процедура)
  - [Что такое _«триггер»_?](#что-такое-триггер)
  - [Что такое _«курсор»_?](#что-такое-курсор)
  - [Опишите разницу типов данных `DATETIME` и `TIMESTAMP`.](#опишите-разницу-типов-данных-datetime-и-timestamp)
  - [Для каких числовых типов недопустимо использовать операции сложения/вычитания?](#для-каких-числовых-типов-недопустимо-использовать-операции-сложениявычитания)
  - [Какое назначение у операторов `PIVOT` и `UNPIVOT` в Transact-SQL?](#какое-назначение-у-операторов-pivot-и-unpivot-в-transact-sql)
  - [Расскажите об основных функциях ранжирования в Transact-SQL.](#расскажите-об-основных-функциях-ранжирования-в-transact-sql)
  - [Для чего используются операторы `INTERSECT`, `EXCEPT` в Transact-SQL?](#для-чего-используются-операторы-intersect-except-в-transact-sql)
  - [Напишите запрос...](#напишите-запрос)
- [Источники](#источники)

## Что такое _«SQL»_?
SQL, Structured query language («язык структурированных запросов») — формальный непроцедурный язык программирования, применяемый для создания, модификации и управления данными в произвольной реляционной базе данных, управляемой соответствующей системой управления базами данных (СУБД).

Формальный - множество конечных слов (строк, цепочек) над конечным алфавитом. Различают языки естественные, на которых общаются люди, и искусственные (или формальные).

Непроцедурный - каждый оператор выдает результат, соответствующий запрашиваемому выходу. Ответственность за то, как  добиться соответствующего выхода, лежит, в значительной степени, на моторе  (движке)  базы данных.

[к оглавлению](#sql)

## Какие существуют операторы SQL?
__операторы определения данных (Data Definition Language, DDL)__:

+ `CREATE` создает объект БД (базу, таблицу, представление, пользователя и т. д.),
+ `ALTER` изменяет объект,
+ `DROP` удаляет объект,
+ `TRUNCATE` - удаляет таблицу и создает ее заново. Причем если на эту таблицу есть ссылки `FOREGIN KEY` или таблица используется в репликации, то пересоздать такую таблицу не получится.
+ `RENAME` переименовыывает объект;

__операторы манипуляции данными (Data Manipulation Language, DML)__:

+ `SELECT` выбирает данные, удовлетворяющие заданным условиям,
+ `INSERT` добавляет новые данные,
+ `UPDATE` изменяет существующие данные,
+ `DELETE` удаляет данные;

__операторы определения доступа к данным (Data Control Language, DCL)__:

+ `GRANT` предоставляет пользователю (группе) разрешения на определенные операции с объектом,
+ `REVOKE` отзывает ранее выданные разрешения,
+ `DENY` задает запрет, имеющий приоритет над разрешением;

__операторы управления транзакциями (Transaction Control Language, TCL)__:

+ `COMMIT` применяет транзакцию,
+ `ROLLBACK` откатывает все изменения, сделанные в контексте текущей транзакции,
+ `SAVEPOINT` разбивает транзакцию на более мелкие.

[к оглавлению](#sql)

## Что означает `NULL` в SQL?
`NULL` - специальное значение (псевдозначение), которое может быть записано в поле таблицы базы данных. NULL соответствует понятию «пустое поле», то есть «поле, не содержащее никакого значения».

`NULL` означает отсутствие, неизвестность информации. Значение `NULL` не является значением в полном смысле слова: по определению оно означает отсутствие значения и не принадлежит ни одному типу данных. Поэтому `NULL` не равно ни логическому значению `FALSE`, ни _пустой строке_, ни `0`. При сравнении `NULL` с любым значением будет получен результат `NULL`, а не `FALSE` и не `0`. Более того, `NULL` не равно `NULL`!

[к оглавлению](#sql)

## Что такое _«временная таблица»_? Для чего она используется?
__Временная таблица__ - это объект базы данных, который хранится и управляется системой базы данных на временной основе. Они могут быть локальными или глобальными. Используется для сохранения результатов вызова хранимой процедуры, уменьшение числа строк при соединениях, агрегирование данных из различных источников или как замена курсоров и параметризованных представлений.

[к оглавлению](#sql)

## Что такое _«представление» (view)_ и для чего оно применяется?
__Представление__, View - виртуальная таблица, представляющая данные одной или более таблиц альтернативным образом. Представления широко используются когда необходимо представить структуру базы данных в удобном для восприятия человеком виде, а так же в соображениях безопасности, предоставляя пользователям возможность обращаться к данным, но не разрешая им доступ к исходным таблицам.

В действительности представление – всего лишь результат выполнения оператора `SELECT`, который хранится в структуре памяти, напоминающей SQL таблицу. Они работают в запросах и операторах DML точно также как и основные таблицы, но не содержат никаких собственных данных. Представления значительно расширяют возможности управления данными. Это способ дать публичный доступ к некоторой (но не всей) информации в таблице.

Для создания представления используется оператор SQL CREATE и синтаксис выглядит следующим образом:
```java
CREATE VIEW view_name
AS SELECT column_name
FROM table_name
WHERE condition
```

[к оглавлению](#sql)

## Каков общий синтаксис оператора `SELECT`?
`SELECT` - оператор DML SQL, возвращающий набор данных (выборку) из базы данных, удовлетворяющих заданному условию. Имеет следующую структуру:

```sql
SELECT 
       [DISTINCT | DISTINCTROW | ALL]
       select_expression,...
   FROM table_references
     [WHERE where_definition]
     [GROUP BY {unsigned_integer | column | formula}]
     [HAVING where_definition]
     [ORDER BY {unsigned_integer | column | formula} [ASC | DESC], ...]
```

[к оглавлению](#sql)

## Что такое `JOIN`?
__JOIN__ - оператор языка SQL, который является реализацией операции соединения реляционной алгебры. Предназначен для обеспечения выборки данных из двух таблиц и включения этих данных в один результирующий набор. 

Особенностями операции соединения являются следующее:

+ в схему таблицы-результата входят столбцы обеих исходных таблиц (таблиц-операндов), то есть схема результата является «сцеплением» схем операндов;
+ каждая строка таблицы-результата является «сцеплением» строки из одной таблицы-операнда со строкой второй таблицы-операнда;
+ при необходимости соединения не двух, а нескольких таблиц, операция соединения применяется несколько раз (последовательно).

```sql
SELECT
  field_name [,... n]
FROM
  Table1
  {INNER | {LEFT | RIGHT | FULL} OUTER | CROSS } JOIN
  Table2
    {ON <condition> | USING (field_name [,... n])}
```

[к оглавлению](#sql)

## Какие существуют типы `JOIN`?
__(INNER) JOIN__
Результатом объединения таблиц являются записи, общие для левой и правой таблиц. Порядок таблиц для оператора не важен, поскольку оператор является симметричным.

__LEFT (OUTER) JOIN__
Производит выбор всех записей первой таблицы и соответствующих им записей второй таблицы. Если записи во второй таблице не найдены, то вместо них подставляется пустой результат (`NULL`). Порядок таблиц для оператора важен, поскольку оператор не является симметричным.

__RIGHT (OUTER) JOIN__
`LEFT JOIN` с операндами, расставленными в обратном порядке. Порядок таблиц для оператора важен, поскольку оператор не является симметричным.

__FULL (OUTER) JOIN__
Результатом объединения таблиц являются все записи, которые присутствуют в таблицах. Порядок таблиц для оператора не важен, поскольку оператор является симметричным.

__CROSS JOIN (декартово произведение)__
При выборе каждая строка одной таблицы объединяется с каждой строкой второй таблицы, давая тем самым все возможные сочетания строк двух таблиц. Порядок таблиц для оператора не важен, поскольку оператор является симметричным.

[к оглавлению](#sql)

## Что лучше использовать `JOIN` или подзапросы?
Обычно лучше использовать `JOIN`, поскольку в большинстве случаев он более понятен и лучше оптимизируется СУБД (но 100% этого гарантировать нельзя). Так же `JOIN` имеет заметное преимущество над подзапросами в случае, когда список выбора `SELECT` содержит столбцы более чем из одной таблицы.

Подзапросы лучше использовать в случаях, когда нужно вычислять агрегатные значения и использовать их для сравнений во внешних запросах.

[к оглавлению](#sql)

## Для чего используется оператор `HAVING`?
`HAVING` используется для фильтрации результата `GROUP BY` по заданным логическим условиям.

[к оглавлению](#sql)

## В чем различие между операторами `HAVING` и `WHERE`?
`WHERE` - это ограничивающее выражение. Оно выполняется до того, как будет получен результат операции. WHERE служит для задания дополнительного условия выборки, операций вставки, редактирования и удаления записей. Условие (condition) может включать в себя предикаты AND, OR, NOT, LIKE, BETWEEN, IS, IN, ключевое слово NULL, операторы сравнения и равенства (<, >, =).
```java
SELECT * FROM Planets WHERE Radius BETWEEN 3000 AND 9000
```

`HAVING` - Оператор SQL HAVING является указателем на результат выполнения агрегатных функций. Агрегатной функцией в языке SQL называется функция, возвращающая какое-либо одно значение по набору значений столбца. Такими функциями являются: SQL COUNT(), SQL MIN(), SQL MAX(), SQL AVG(), SQL SUM().
```java
SELECT Singer, SUM(Sale)
FROM Artists
GROUP BY Singer
HAVING SUM(Sale) > 2000000
```

Выражения WHERE используются вместе с операциями SELECT, UPDATE, DELETE, в то время как HAVING только с SELECT и предложением GROUP BY.


[к оглавлению](#sql)

## Для чего используется оператор `ORDER BY`?
__ORDER BY__ упорядочивает вывод запроса согласно значениям в том или ином количестве выбранных столбцов. Многочисленные столбцы упорядочиваются один внутри другого. Возможно определять возрастание `ASC` или убывание `DESC` для каждого столбца. По умолчанию установлено - возрастание.

[к оглавлению](#sql)

## Для чего используется оператор `GROUP BY`?
`GROUP BY` используется для агрегации записей результата по заданному столбцу.

[к оглавлению](#sql)

## Как `GROUP BY` обрабатывает значение `NULL`?
При использовании `GROUP BY` все значения `NULL` считаются равными.

[к оглавлению](#sql)

## В чем разница между операторами `GROUP BY` и `DISTINCT`?
`DISTINCT` указывает, что для вычислений используются только уникальные значения столбца. `NULL` считается как отдельное значение. DISTINCT нашел широкое применение в операторе SQL SELECT, для выборки уникальных значений. Так же используется в агрегатных функциях. 
```java
SELECT DISTINCT column_name FROM table_name
```

`GROUP BY` используется для объединения результатов выборки по одному или нескольким столбцам. создает отдельную группу для всех возможных значений (включая значение `NULL`). 

Если нужно удалить только дубликаты лучше использовать `DISTINCT`, `GROUP BY` лучше использовать для определения групп записей, к которым могут применяться агрегатные функции.

[к оглавлению](#sql)

## Перечислите основные агрегатные функции.
__Агрегатных функции__ - функции, которые берут группы значений и сводят их к одиночному значению. 

SQL предоставляет несколько агрегатных функций:

`COUNT` - производит подсчет записей, удовлетворяющих условию запроса;
`SUM` - вычисляет арифметическую сумму всех значений колонки;
`AVG` - вычисляет среднее арифметическое всех значений;
`MAX` - определяет наибольшее из всех выбранных значений;
`MIN` - определяет наименьшее из всех выбранных значений.

[к оглавлению](#sql)

## В чем разница между `COUNT(*)` и `COUNT({column})`?
`COUNT (*)` подсчитывает количество записей в таблице, не игнорируя значение NULL, поскольку эта функция оперирует записями, а не столбцами.

`COUNT ({column})` подсчитывает количество значений в `{column}`. При подсчете количества значений столбца эта форма функции `COUNT` не принимает во внимание значение `NULL`.

[к оглавлению](#sql)

## Что делает оператор `EXISTS`?
`EXISTS` берет подзапрос, как аргумент, и оценивает его как `TRUE`, если подзапрос возвращает какие-либо записи и `FALSE`, если нет.

[к оглавлению](#sql)

## Для чего используются операторы `IN`, `BETWEEN`, `LIKE`?
`IN` - определяет набор значений.

```sql 
SELECT * FROM Persons WHERE name IN ('Ivan','Petr','Pavel');
```

`BETWEEN` определяет диапазон значений. В отличие от `IN`, `BETWEEN` чувствителен к порядку, и первое значение в предложении должно быть первым по алфавитному или числовому порядку.

```sql 
SELECT * FROM Persons WHERE age BETWEEN 20 AND 25;
```

`LIKE` применим только к полям типа `CHAR` или `VARCHAR`, с которыми он используется чтобы находить подстроки. В качестве условия используются _символы шаблонизации (wildkards_) - специальные символы, которые могут соответствовать чему-нибудь: 

+ `_` замещает любой одиночный символ. Например, `'b_t'` будет соответствовать словам `'bat'` или `'bit'`, но не будет соответствовать `'brat'`. 

+ `%` замещает последовательность любого числа символов. Например `'%p%t'` будет соответствовать словам `'put'`, `'posit'`, или `'opt'`, но не `'spite'`.

```sql 
SELECT * FROM UNIVERSITY WHERE NAME LIKE '%o';
```

[к оглавлению](#sql)

## Для чего применяется ключевое слово `UNION`?
В языке SQL ключевое слово `UNION` применяется для объединения результатов двух SQL-запросов в единую таблицу, состоящую из схожих записей. Оба запроса должны возвращать одинаковое число столбцов и совместимые типы данных в соответствующих столбцах. Необходимо отметить, что `UNION` сам по себе не гарантирует порядок записей. Записи из второго запроса могут оказаться в начале, в конце или вообще перемешаться с записями из первого запроса. В случаях, когда требуется определенный порядок, необходимо использовать `ORDER BY`.

С удалением дублей:
```sql 
SELECT * FROM имя_таблицы1 WHERE условие
	UNION SELECT * FROM имя_таблицы2 WHERE условие
```
Без удаления дублей:
```sql 
SELECT * FROM имя_таблицы1 WHERE условие
	UNION ALL SELECT * FROM имя_таблицы2 WHERE условие
```
Можно объединять не две таблицы, а три или более:
```sql 
SELECT * FROM имя_таблицы1 WHERE условие
	UNION SELECT * FROM имя_таблицы2 WHERE условие
	UNION SELECT * FROM имя_таблицы3 WHERE условие
	UNION SELECT * FROM имя_таблицы4 WHERE услови
```
[к оглавлению](#sql)

## Какие ограничения на целостность данных существуют в SQL?
__sql constraint__

`PRIMARY KEY` - набор полей (1 или более), значения которых образуют уникальную комбинацию и используются для однозначной идентификации записи в таблице. Для таблицы может быть создано только одно такое ограничение. Данное ограничение используется для обеспечения целостности сущности, которая описана таблицей.

`CHECK` используется для ограничения множества значений, которые могут быть помещены в данный столбец. Это ограничение используется для обеспечения целостности предметной области, которую описывают таблицы в базе.

`UNIQUE` обеспечивает отсутствие дубликатов в столбце или наборе столбцов.

`FOREIGN KEY` защищает от действий, которые могут нарушить связи между таблицами. `FOREIGN KEY` в одной таблице указывает на `PRIMARY KEY` в другой. Поэтому данное ограничение нацелено на то, чтобы не было записей `FOREIGN KEY`, которым не отвечают записи `PRIMARY KEY`.

[к оглавлению](#sql)

## Какие отличия между ограничениями `PRIMARY` и `UNIQUE`?
По умолчанию ограничение `PRIMARY` создает кластерный индекс на столбце, а `UNIQUE` - некластерный. Другим отличием является то, что `PRIMARY` не разрешает `NULL` записей, в то время как `UNIQUE` разрешает одну (а в некоторых СУБД несколько) `NULL` запись.

[к оглавлению](#sql)

## Может ли значение в столбце, на который наложено ограничение `FOREIGN KEY`, равняться `NULL`?
Может, если на данный столбец не наложено ограничение `NOT NULL`. 

[к оглавлению](#sql)

## Как создать индекс? 
Индекс можно создать либо с помощью выражения `CREATE INDEX`: 
```sql
CREATE INDEX index_name ON table_name (column_name)
```

либо указав ограничение целостности в виде уникального `UNIQUE` или первичного `PRIMARY` ключа в операторе создания таблицы `CREATE TABLE`.

[к оглавлению](#sql)

## Что делает оператор `MERGE`?
`MERGE` позволяет осуществить слияние данных одной таблицы с данными другой таблицы. При слиянии таблиц проверяется условие, и если оно истинно, то выполняется `UPDATE`, а если нет - `INSERT`. При этом изменять поля таблицы в секции `UPDATE`, по которым идет связывание двух таблиц, нельзя.

[к оглавлению](#sql)

## В чем отличие между операторами `DELETE` и `TRUNCATE`?
`DELETE` - оператор DML, удаляет записи из таблицы, которые удовлетворяют критерию `WHERE` при этом задействуются триггеры, ограничения и т.д.

`TRUNCATE` - DDL оператор. удаляет таблицу (для мгновенной очистки всех строк) и создает ее заново. Причем если на эту таблицу есть ссылки `FOREGIN KEY` или таблица используется в репликации, то пересоздать такую таблицу не получится.

+ Оператор SQL TRUNCATE не ведет запись об удаленных данных в журнал событий.
+ SQL DELETE осуществляет блокировку построчно, оператор SQL TRUNCATE по всей странице целиком. Вследствие этого, оператор SQL TRUNCATE не возвращает никакого значения, SQL DELETE же, возвращает количество удаленных строк.
+ После применения оператора SQL DELETE возможно сделать откат операции и восстановить удаленные данные (команда ROLLBACK). При применении оператора SQL TRUNCATE этого сделать нельзя, однако в СУБД MS SQL Server, оператор может применяться в транзакциях.

[к оглавлению](#sql)

## Что делает оператор `EXPLAIN`?
```java
EXPLAIN имя_таблицы
EXPLAIN SELECT опции_выборки
```
Если оператор SELECT предваряется ключевым словом EXPLAIN, MySQL сообщит о том, как будет производиться обработка SELECT, и предоставит информацию о порядке и методе связывания таблиц.

При помощи EXPLAIN можно выяснить, когда стоит снабдить таблицы индексами, чтобы получить более быструю выборку, использующую индексы для поиска записей. Кроме того, можно проверить, насколько удачный порядок связывания таблиц был выбран оптимизатором. Заставить оптимизатор связывать таблицы в заданном порядке можно при помощи указания STRAIGHT_JOIN.

Для непростых соединений EXPLAIN возвращает строку информации о каждой из использованных в работе оператора SELECT таблиц. Таблицы перечисляются в том порядке, в котором они будут считываться. MySQL выполняет все связывания за один проход (метод называется "single-sweep multi-join"). Делается это так: MySQL читает строку из первой таблицы, находит совпадающую строку во второй таблице, затем - в третьей, и так далее. Когда обработка всех таблиц завершается, MySQL выдает выбранные столбцы и обходит в обратном порядке список таблиц до тех пор, пока не будет найдена таблица с наибольшим совпадением строк. Следующая строка считывается из этой таблицы и процесс продолжается в следующей таблице.

```java
********************** 1. row **********************
id: 1
select_type: SIMPLE
table: categories
type: ALL
possible_keys: NULL
key: NULL
key_len: NULL
ref: NULL
rows: 4
Extra: 
1 row in set (0.00 sec)
```

+ id – порядковый номер для каждого SELECT’а внутри запроса (когда имеется несколько подзапросов)
select_type – тип запроса SELECT.

+ SIMPLE — Простой запрос SELECT без подзапросов или UNION’ов
+ PRIMARY – данный SELECT – самый внешний запрос в JOIN’е
+ DERIVED – данный SELECT является частью подзапроса внутри FROM
+ SUBQUERY – первый SELECT в подзапросе
+ DEPENDENT SUBQUERY – подзапрос, который зависит от внешнего запроса
+ UNCACHABLE SUBQUERY – не кешируемый подзапрос (существуют определенные условия для того, чтобы запрос кешировался)
+ UNION – второй или последующий SELECT в UNION’е
+ DEPENDENT UNION – второй или последующий SELECT в UNION’е, зависимый от внешнего запроса
+ UNION RESULT – результат UNION’а

+ Table – таблица, к которой относится выводимая строка
+ Type — указывает на то, как MySQL связывает используемые таблицы. Это одно из наиболее полезных полей в выводе потому, что может сообщать об отсутствующих индексах или почему написанный запрос должен быть пересмотрен и переписан.
Возможные значения:

+ System – таблица имеет только одну строку
+ Const – таблица имеет только одну соответствующую строку, которая проиндексирована. Это наиболее быстрый тип соединения потому, что таблица читается только один раз и значение строки может восприниматься при дальнейших соединениях как константа.
+ Eq_ref – все части индекса используются для связывания. Используемые индексы: PRIMARY KEY или UNIQUE NOT NULL. Это еще один наилучший возможный тип связывания.
+ Ref – все соответствующие строки индексного столбца считываются для каждой комбинации строк из предыдущей таблицы. Этот тип соединения для индексированных столбцов выглядит как использование операторов = или < = >
+ Fulltext – соединение использует полнотекстовый индекс таблицы
+ Ref_or_null – то же самое, что и ref, но также содержит строки со значением null для столбца
+ Index_merge – соединение использует список индексов для получения результирующего набора. Столбец key вывода команды EXPLAIN будет содержать список использованных индексов.
+ Unique_subquery – подзапрос IN возвращает только один результат из таблицы и использует первичный ключ.
+ Index_subquery – тоже, что и предыдущий, но возвращает более одного результата.
+ Range – индекс, использованный для нахождения соответствующей строки в определенном диапазоне, обычно, когда ключевой столбец сравнивается с константой, используя операторы вроде: BETWEEN, IN, >, >=, etc.
+ Index – сканируется все дерево индексов для нахождения соответствующих строк.
+ All – Для нахождения соответствующих строк используются сканирование всей таблицы. Это наихудший тип соединения и обычно указывает на отсутствие подходящих индексов в таблице.

+ Possible_keys – показывает индексы, которые могут быть использованы для нахождения строк в таблице. На практике они могут использоваться, а могут и не использоваться. Фактически, этот столбец может сослужить добрую службу в деле оптимизации запросов, т.к значение NULL указывает на то, что не найдено ни одного подходящего индекса .
+ Key– указывает на использованный индекс. Этот столбец может содержать индекс, не указанный в столбце possible_keys. В процессе соединения таблиц оптимизатор ищет наилучшие варианты и может найти ключи, которые не отображены в possible_keys, но являются более оптимальными для использования.
+ Key_len – длина индекса, которую оптимизатор MySQL выбрал для использования. Например, значение key_len, равное 4, означает, что памяти требуется для хранения 4 знаков. На эту тему вот cсылка
+ Ref – указываются столбцы или константы, которые сравниваются с индексом, указанным в поле key. MySQL выберет либо значение константы для сравнения, либо само поле, основываясь на плане выполнения запроса.
+ Rows – отображает число записей, обработанных для получения выходных данных. Это еще одно очень важное поле, которое дает повод оптимизировать запросы, особенно те, которые используют JOIN’ы и подзапросы.
+ Extra – содержит дополнительную информацию, относящуюся к плану выполнения запроса. Такие значения как “Using temporary”, “Using filesort” и т.д могут быть индикатором проблемного запроса. С полным списком возможных значений вы можете ознакомиться здесь

[к оглавлению](#sql)

## Что такое _«RETURNING»_?
Иногда бывает полезно получать данные из модифицируемых строк в процессе их обработки. Это возможно с использованием предложения RETURNING, которое можно задать для команд INSERT, UPDATE и DELETE. Применение RETURNING позволяет обойтись без дополнительного запроса к базе для сбора данных и это особенно ценно, когда как-то иначе трудно получить изменённые строки надёжным образом.

Точно работает в PostgreSQL

```java
INSERT INTO users (firstname, lastname) VALUES ('Joe', 'Cool') RETURNING id;

В команде UPDATE данные, выдаваемые в RETURNING, образуются новым содержимым изменённой строки. Например:
UPDATE products SET price = price * 1.10
  WHERE price <= 99.99
  RETURNING name, price AS new_price;

В команде DELETE данные, выдаваемые в RETURNING, образуются содержимым удалённой строки. Например:
DELETE FROM products
  WHERE obsoletion_date = 'today'
  RETURNING *;
 ```

[к оглавлению](#sql)

## Что такое _«хранимая процедура»_?
__Хранимая процедура__ — объект базы данных, представляющий собой набор SQL-инструкций, который хранится на сервере. Хранимые процедуры очень похожи на обыкновенные процедуры языков высокого уровня, у них могут быть входные и выходные параметры и локальные переменные, в них могут производиться числовые вычисления и операции над символьными данными, результаты которых могут присваиваться переменным и параметрам. В хранимых процедурах могут выполняться стандартные операции с базами данных (как DDL, так и DML). Кроме того, в хранимых процедурах возможны циклы и ветвления, то есть в них могут использоваться инструкции управления процессом исполнения.

Хранимые процедуры позволяют повысить производительность, расширяют возможности программирования и поддерживают функции безопасности данных. В большинстве СУБД при первом запуске хранимой процедуры она компилируется (выполняется синтаксический анализ и генерируется план доступа к данным) и в дальнейшем её обработка осуществляется быстрее.

[к оглавлению](#sql)

## Что такое _«триггер»_?
__Триггер (trigger)__ — это хранимая процедура особого типа, которую пользователь не вызывает непосредственно, а исполнение которой обусловлено действием по модификации данных: добавлением, удалением или изменением данных в заданной таблице реляционной базы данных. Триггеры применяются для обеспечения целостности данных и реализации сложной бизнес-логики. Триггер запускается сервером автоматически и все производимые им модификации данных рассматриваются как выполняемые в транзакции, в которой выполнено действие, вызвавшее срабатывание триггера. Соответственно, в случае обнаружения ошибки или нарушения целостности данных может произойти откат этой транзакции.

Момент запуска триггера определяется с помощью ключевых слов `BEFORE` (триггер запускается до выполнения связанного с ним события) или `AFTER` (после события). В случае, если триггер вызывается до события, он может внести изменения в модифицируемую событием запись. Кроме того, триггеры могут быть привязаны не к таблице, а к представлению (VIEW). В этом случае с их помощью реализуется механизм «обновляемого представления». В этом случае ключевые слова `BEFORE` и `AFTER` влияют лишь на последовательность вызова триггеров, так как собственно событие (удаление, вставка или обновление) не происходит.

[к оглавлению](#sql)

## Что такое _«курсор»_?
__Курсор__ — это объект базы данных, который позволяет приложениям работать с записями «по-одной», а не сразу с множеством, как это делается в обычных SQL командах.

Порядок работы с курсором такой:

+ Определить курсор (`DECLARE`)
+ Открыть курсор (`OPEN`)
+ Получить запись из курсора (`FETCH`)
+ Обработать запись...
+ Закрыть курсор (`CLOSE`)
+ Удалить ссылку курсора (`DEALLOCATE`). Когда удаляется последняя ссылка курсора, SQL освобождает структуры данных, составляющие курсор.

[к оглавлению](#sql)

## Опишите разницу типов данных `DATETIME` и `TIMESTAMP`.
`DATETIME` предназначен для хранения целого числа: `YYYYMMDDHHMMSS`. И это время не зависит от временной зоны настроенной на сервере.
Размер: 8 байт

`TIMESTAMP` хранит значение равное количеству секунд, прошедших с полуночи 1 января 1970 года по усреднённому времени Гринвича. При получении из базы отображается с учётом часового пояса. Размер: 4 байта

[к оглавлению](#sql)

## Для каких числовых типов недопустимо использовать операции сложения/вычитания?
В качестве операндов операций сложения и вычитания нельзя использовать числовой тип `BIT`.

[к оглавлению](#sql)

## Какое назначение у операторов `PIVOT` и `UNPIVOT` в Transact-SQL?
`PIVOT` и `UNPIVOT` являются нестандартными реляционными операторами, которые поддерживаются Transact-SQL. 

Оператор `PIVOT` разворачивает возвращающее табличное значение выражение, преобразуя уникальные значения одного столбца выражения в несколько выходных столбцов, а также, в случае необходимости, объединяет оставшиеся повторяющиеся значения столбца и отображает их в выходных данных. Оператор `UNPIVOT` производит действия, обратные `PIVOT`, преобразуя столбцы возвращающего табличное значение выражения в значения столбца.

[к оглавлению](#sql)

## Расскажите об основных функциях ранжирования в Transact-SQL.
Ранжирующие функции - это функции, которые возвращают значение для каждой записи группы в результирующем наборе данных. На практике они могут быть использованы, например, для простой нумерации списка, составления рейтинга или постраничной навигации.

`ROW_NUMBER` – функция нумерации в Transact-SQL, которая возвращает просто номер записи.

`RANK` возвращает ранг каждой записи. В данном случае, в отличие от `ROW_NUMBER`, идет уже анализ значений и в случае нахождения одинаковых возвращает одинаковый ранг с пропуском следующего.

`DENSE_RANK` так же возвращает ранг каждой записи, но в отличие от `RANK` в случае нахождения одинаковых значений возвращает ранг без пропуска следующего.

`NTILE` – функция Transact-SQL, которая делит результирующий набор на группы по определенному столбцу. 

[к оглавлению](#sql)

## Для чего используются операторы `INTERSECT`, `EXCEPT` в Transact-SQL?
Оператор `EXCEPT` возвращает уникальные записи из левого входного запроса, которые не выводятся правым входным запросом.

Оператор `INTERSECT` возвращает уникальные записи, выводимые левым и правым входными запросами.

[к оглавлению](#sql)

## Напишите запрос...
```sql
CREATE TABLE table ( 
  id BIGINT(20) NOT NULL AUTO_INCREMENT, 
  created TIMESTAMP NOT NULL DEFAULT 0,
  PRIMARY KEY (id) 
);
```

Требуется написать запрос который вернет максимальное значение `id` и значение `created` для этого `id`:

```sql
SELECT id, created FROM table where id = (SELECT MAX(id) FROM table);
```

---

```sql
CREATE TABLE track_downloads ( 
  download_id BIGINT(20) NOT NULL AUTO_INCREMENT, 
  track_id INT NOT NULL, 
  user_id BIGINT(20) NOT NULL, 
  download_time TIMESTAMP NOT NULL DEFAULT 0, 
  PRIMARY KEY (download_id) 
);
```

Напишите SQL-запрос, возвращающий все пары `(download_count, user_count)`, удовлетворяющие следующему условию: `user_count` — общее ненулевое число пользователей, сделавших ровно `download_count` скачиваний `19 ноября 2010 года`:

```sql
SELECT DISTINCT download_count, COUNT(*) AS user_count 
FROM ( 
    SELECT COUNT(*) AS download_count  
    FROM track_downloads WHERE download_time="2010-11-19" 
    GROUP BY user_id)  
AS download_count
GROUP BY download_count; 
```

[к оглавлению](#sql)

# Источники
+ [Википедия](https://ru.wikipedia.org/wiki/SQL)
+ [Quizful](http://www.quizful.net/interview/sql)

[Вопросы для собеседования](README.md)
